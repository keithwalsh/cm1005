---
id: 00dbc8ea-dc30-4570-8998-7cb20fd0223e
type: lecture
created: 2026-01-18
updated: 2026-01-18
title: Working with numbers
lesson: Lesson 4.2 Conditionals with types
unit: Topic 4 Conditionals and variable types
course: CM1005 Introduction to Programming I
certificate: BSc Computer Science
url: https://www.coursera.org/learn/uol-introduction-to-programming-1/lecture/GavM3/working-with-numbers
---

# Introduction to Comparing Numbers in Conditionals

In the conditionals you've seen so far, you've compared values using the "equal to" notation (==) to see if they are the same, or using "not equal to" (!=) if they are different. Now, let's look beyond that and use other mathematical notation you are likely very familiar with—**greater than** and **less than**—to compare numbers in different ways.

By doing this, we will look at different regions within your sketch. For example, we might divide up the canvas and check where the mouse is. Using these techniques, we can build things like collision detection and create interactive buttons. You've already seen the symbols == and != several times.

## Introducing Greater Than and Less Than

Now, we need to use some new notation: 

- **Greater than** (`>`)  
This is the angle bracket on your keyboard, and we can also use **greater than or equal to** (`>=`). This means that a value is either the same as or larger than another value. Obviously, these comparisons only apply to numbers.

- **Less than** (`<`)  
This is the open angle bracket. In a similar way, we have **less than or equal to** (`<=`).

Let's move on to some code and see how this works.

---

# Building a Treasure Hunting Game

In this video, we're going to build up to making a treasure hunting game. We'll need a treasure map—a pirate treasure map—along with a sketch that loads it. 

The `loadImage` function points to a map image (`map.jpeg`) in the same folder as the sketch. We're also loading a pirate font—again, the font file is in the same directory as the sketch. The `image` function loads the map in the top-left hand corner of the sketch.

Before building the actual game, let's play with these new conditionals to identify some regions within the map.

## Dividing the Map: Top and Bottom (North and South)

Let's start by dividing the sketch into top and bottom, or north and south. We can track the mouse pointer:

- If the mouse pointer is in the **top half** of the map, color that region and display "North" at the bottom.
- If the mouse pointer is in the **bottom half**, draw a rectangle at the bottom, color it, and display "South".

To do this, we need conditionals. Check if `mouseY` (the vertical position of the mouse) is **less than** half the height of the canvas. If so, draw a rectangle at the top, starting at `(0,0)`, with a width equal to the canvas and a height of half the canvas, using a red fill (`fill(255,0,0,100)`) for some transparency so the map remains visible underneath.

If the mouse is in the bottom half, the `else` block executes. Set the fill to green with some transparency, and draw a rectangle starting at `height/2`, with the width of the screen and a height of half the screen.

If you save and run this sketch, you'll see the top half turn red when the mouse is there, and the bottom half turns green as you move the mouse down. 

### Using a Variable to Show Region

There's a variable called `lock`, used to save and display whether the mouse is in the north or the south. Some text is printed with the value of `lock` in the bottom left of the screen.

All you need to do is set `lock = "N"` when the mouse is in the top half and `lock = "S"` when in the bottom. Don’t forget your semicolons! When you run this, you’ll see a piratey font telling you which half of the map the mouse is in.

---

# Extending the Idea: Four Quarters of the Map

Let's go further and split the map into **four quarters**: northeast, northwest, southeast, and southwest. This requires extra conditionals.

Start by handling the top half of the map, and add more checks for the horizontal position (`mouseX`):

- **Northwest:** Top half (`mouseY < height/2`) **and** left half (`mouseX < width/2`)
- **Northeast:** Top half (`mouseY < height/2`) **and** right half (`mouseX > width/2`)

For color, you might use blue (`fill(0,0,255,100)`) for northeast. The rectangles should be half the width and half the height, starting at the appropriate `(x, y)`.

Don’t forget to adjust both width and height to be half for these rectangles. Set the `lock` variable to "northwest" or "northeast" accordingly.

### Bottom Half

- **Southwest:** Bottom half (`mouseY > height/2`) **and** left half (`mouseX < width/2`)
- **Southeast:** Bottom half (`mouseY > height/2`) **and** right half (`mouseX > width/2`)

West can be purple. Start the rectangle at `(0, height/2)` for southwest, and at `(width/2, height/2)` for southeast. Update the `lock` variable for each region.

When you run the sketch, moving the mouse between these four quadrants should accurately update both the color and the label (southwest, northwest, etc.).

---

## Handling the Borders between Regions

If you move the mouse exactly onto the boundary between regions, you may notice the default "else" clause runs because the pixel isn't included in any region. This happens because we used strictly less-than (`<`) and greater-than (`>`) comparisons. There's a one-pixel-wide strip not caught by any condition.

To fix this, adjust your comparisons to use **less-than-or-equal-to** (`<=`) or **greater-than-or-equal-to** (`>=`). This ensures that all possible positions are covered. Once done, the issue is resolved—you'll never hit the default clause when on a border.

---

# Starting the Treasure Hunt Game

Let's build on the previous map example by starting our treasure hunt game.

The new sketch you’ll use (which you can download from the resources tab) is similar, but now has an "X" marking the spot of the buried treasure, and a message explains whether you’ve found the treasure.

At first, the game is trivially easy. You just have to click on the X location. If you do, it tells you that you found treasure; otherwise, you get "pieces of nothing". To start, create a `mousePressed` function to handle clicks—p5 will call this function every time the mouse is pressed.

You'll need a new if-statement to check if the mouse cursor is **in the vicinity** of the treasure's coordinates rather than exactly on them.

### Storing Treasure Coordinates

In the sketch, there are two variables for the treasure’s coordinates — X and Y. They are randomly set within the map on each sketch run, so the X will move each time. 

To check for a "hit," you don't need pixel-level precision. Accept clicks *around* the X, as well as directly on it. You can use the `dist` (distance) function in p5.js for this calculation. 

The `dist` function takes four parameters: the first point (`mouseX`, `mouseY`) and the second (`treasureX`, `treasureY`), and returns the distance between them. Wrap this in an if-statement: if the distance is **less than or equal to 15**, the click is close enough and counts as hitting the treasure.

For example, a click within 12 or 13 pixels is close enough, while a click 40 pixels away is not.

### Updating the Message

Use the distance function in your if statement. If the mouse click is within 15 pixels of the treasure, set the message to "Pieces-o-eight." Otherwise, keep or set the message to "pieces of nothing."

Save and test! If you click on the X, the message updates. Click elsewhere, and it resets to "pieces of nothing."

---

# Making the Game Harder: Hide and Reveal the X

The game is a little too easy, since the X is always visible. To make it more difficult, hide the X by introducing a Boolean variable, e.g. `showX = false`. Only draw the "X" if `showX` is true. When comparing a Boolean to true, you can just use its name directly.

Now, save and run the sketch. The X will disappear, and you can try to find it by clicking around.

This makes the game a bit *too* hard, so let's add a button that toggles revealing the X.

---

# Adding a Reveal/Hide Button

To add an interactive button for revealing/hiding the X, create an object named `button`. Give it properties:

- X-coordinate (`x`), for example 20
- Y-coordinate (`y`), also 20
- `width` (e.g. 150 or 80)
- `height` (e.g. 100)
- `text` (initially "Reveal")

Draw the button as a rectangle using these properties, e.g. `rect(button.x, button.y, button.width, button.height)`, and use a gray fill. Center the button's text within the button, just as you do in word processors by setting text alignment to center.

If the button looks too big, reduce the width to 80 pixels. If the text isn't displaying, make sure you set the text color back to black.

---

# Detecting Button Clicks: Collision Detection

Now you need to detect when the user clicks the button. Go to your `mousePressed` function. You already use the distance function to check for clicking the X, but for the rectangular button, you'll use collision detection.

Consider each side of the button:

1. **Left side**: Is `mouseX > button.x`?
2. **Right side**: Is `mouseX < button.x + button.width`?
3. **Top side**: Is `mouseY > button.y`?
4. **Bottom side**: Is `mouseY < button.y + button.height`?

All conditions must be true for the mouse click to be *inside* the button.

Put this all in a single if-statement joined by logical ANDs (`&&`). This will determine if the button was clicked.

---

# Toggling the Button and Updating its Label

Once detected, change `showX` to its opposite value (`showX = !showX`). If you run this, you should see the X appearing and disappearing with each click.

To also update the button's label—switching between "Reveal" and "Hide"—just nest another if-statement:

- If `showX` is true, set `button.text = "Hide"`
- If not, set `button.text = "Reveal"`

Check for mistakes, such as forgetting to put these values in quotes.

---

Now, you can click to reveal or hide the X. This demonstrates greater and less than comparisons, as well as collision detection. We’ve taken conditionals further—not just checking for equality, but also whether values are greater than or less than each other—giving you powerful tools for future game projects.

