---
id: fd05c75f-0223-42ed-ba43-d802843ad7f8
type: lecture
created: 2026-01-18
updated: 2026-01-18
title: Isolation and commenting
lesson: Lesson 4.3 Debugging techniques
unit: Topic 4 Conditionals and variable types
course: CM1005 Introduction to Programming I
certificate: BSc Computer Science
url: https://www.coursera.org/learn/uol-introduction-to-programming-1/lecture/K1sG7/isolation-and-commenting
---



# Introduction

During this course, we've already introduced several debugging techniques. In this lesson, I will show you another valuable method called **commenting and isolation**. This technique will help when the browser stops providing clues about a bug, especially if it's a logic error rather than a syntax error. It's also beneficial when examining someone else's code—perhaps a colleague has asked for your help with a bug, or you’ve returned to your own old code and need to remember how everything works.

To demonstrate this, we'll explore a sketch: a small rocket at the bottom of the screen. When you press `W`, the rocket flies upward. If you also press `D`, it moves right; pressing `A` moves it left. When you release the keys, the rocket starts moving back down toward the ground. While the completed version works, we will focus on a broken version given to us by a colleague who can't fix the issue.

# Assessing the Code

The first step is to **read through the code**. In this example, our colleague hasn't included any comments, which makes our job more difficult. Running the code, we notice, for instance, that `W` moves the rocket and it moves left and right, but it doesn't return to the ground as expected. Checking the browser's inspector reveals no errors; the console is empty, so we don't get any debugging help from the browser. With no external clues, we need to study the code itself.

We see the usual constructs: `setup` and `draw`. They're being called, the canvas is created, and the rocket object is initialized. There are several `if` statements whose purposes aren’t immediately clear, and there are chunks of code drawing shapes, presumably making up parts of the rocket. Lower down, we find handlers for `keyPressed` and `keyReleased`.

# Adding Comments to Understand Functionality

We can start to add some comments as we decipher the code. For example, we might identify:

- Thrust launching the rocket (`W` key).
- Lateral movement: `A` key moves the rocket left, `D` moves it right.

This provides just enough information in the function to understand the controls. Moving to the `keyReleased` function, we see that these functions toggle the `thrust`, `moveRight`, and `moveLeft` variables, setting them to `true` or `false` depending on which keys are pressed or released. So far, this setup looks correct.

# Using Commenting for Isolation

Another helpful technique is isolating which parts of the drawing code produce which visual elements on the screen. To do this, we comment out a section of drawing code and run the program to see what disappears. For example:

- If we highlight a block that defines a shape and comment it out (using `Command` + `/` on Mac or `Control` + `/` on Windows), we observe that the fins still appear, but the main rocket body does not.
- Re-enabling the block restores the affected part.

After observing, we can add comments such as:

- "Draw rocket's body" for the main body block.
- "Draw left fin" and "Draw right fin" for the corresponding sections.
- "If thrust then draw flame" for conditional drawing of a flame beneath the rocket when running.

By systematically commenting and uncommenting, we can map code sections to specific elements in the visual output, which helps in understanding the code's structure and purpose. This process is valuable even when comments exist, as it reinforces your understanding.

# Tracing the Source of the Bug

Through this process, we get closer to identifying the bug. The rocket isn't descending as intended, so we examine the code responsible for movement. 

- When `thrust` is `true`, the rocket moves up—as triggered by pressing `W`. The code checks if `rocket.y` is greater than zero to prevent going off the top of the screen.
- We find a check involving something called `baseline`. What is `baseline`? Searching above, we see `baseline` is declared as a variable and set to a value near the bottom of the screen, actually determining how low the rocket can be drawn.

Upon closer inspection, we see the problem: although `baseline` is declared globally, it's also declared and assigned inside the `setup` function. This **local declaration** inside `setup` isn't accessible elsewhere. Instead of immediately deleting the line, we *comment it out* and write the correct assignment: `baseline = height - 80`.

Running the program, we notice that it does not crash—so far, so good. The problem hasn't been resolved yet, but nothing has broken.

# Correcting the Descent Logic

Next, we scrutinize an `else if` statement responsible for moving the rocket down. It currently says "`else if rocket.y > baseline`", but that doesn't make sense in context. It should check if `rocket.y < baseline` for the descent. Instead of overwriting or deleting, we comment out the incorrect condition and replace it:

- `else if rocket.y < baseline`

We also remove any unnecessary semicolons, save, and run the code. Now, the rocket descends correctly.

# Conclusion: The Value of Commenting and Isolation

By commenting out and isolating parts of the code, we:

- Revealed the effects each section had on the program.
- Made nondestructive changes—enabling easy rollback in case of mistakes.
- Better documented the code for our own understanding or for others in the future.

This method is especially useful for debugging projects, like your upcoming game project, where clear logic and the ability to test changes safely will be valuable.
